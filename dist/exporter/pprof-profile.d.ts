import type { Long } from 'protobufjs/minimal';
import { Writer } from 'protobufjs/minimal';
export interface Profile {
    /**
     * A description of the samples associated with each Sample.value.
     * For a cpu profile this might be:
     *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
     * For a heap profile, this might be:
     *   [["allocations","count"], ["space","bytes"]],
     * If one of the values represents the number of events represented
     * by the sample, by convention it should be at index 0 and use
     * sample_type.unit == "count".
     */
    sampleType: ValueType[];
    /** The set of samples recorded in this profile. */
    sample: Sample[];
    /**
     * Mapping from address ranges to the image/binary/library mapped
     * into that address range.  mapping[0] will be the main binary.
     */
    mapping: Mapping[];
    /** Useful program location */
    location: Location[];
    /** Functions referenced by locations */
    function: Function[];
    /**
     * A common table for strings referenced by various messages.
     * string_table[0] must always be "".
     */
    stringTable: string[];
    /**
     * frames with Function.function_name fully matching the following
     * regexp will be dropped from the samples, along with their successors.
     */
    dropFrames: number;
    /**
     * frames with Function.function_name fully matching the following
     * regexp will be kept, even if it matches drop_functions.
     */
    keepFrames: number;
    /** Time of collection (UTC) represented as nanoseconds past the epoch. */
    timeNanos: number;
    /** Duration of the profile, if a duration makes sense. */
    durationNanos: number;
    /**
     * The kind of events between sampled ocurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     */
    periodType: ValueType | undefined;
    /** The number of events between sampled occurrences. */
    period: number;
    /** Freeform text associated to the profile. */
    comment: number[];
    /**
     * Index into the string table of the type of the preferred sample
     * value. If unset, clients should default to the last sample value.
     */
    defaultSampleType: number;
}
/** ValueType describes the semantics and measurement units of a value. */
export interface ValueType {
    /** Index into string table. */
    type: number;
    /** Index into string table. */
    unit: number;
}
/**
 * Each Sample records values encountered in some program
 * context. The program context is typically a stack trace, perhaps
 * augmented with auxiliary information like the thread-id, some
 * indicator of a higher level request being handled etc.
 */
export interface Sample {
    /**
     * The ids recorded here correspond to a Profile.location.id.
     * The leaf is at location_id[0].
     */
    locationId: number[];
    /**
     * The type and unit of each value is defined by the corresponding
     * entry in Profile.sample_type. All samples must have the same
     * number of values, the same as the length of Profile.sample_type.
     * When aggregating multiple samples into a single sample, the
     * result has a list of values that is the elemntwise sum of the
     * lists of the originals.
     */
    value: number[];
    /**
     * label includes additional context for this sample. It can include
     * things like a thread id, allocation size, etc
     */
    label: Label[];
}
export interface Label {
    /** Index into string table */
    key: number;
    /** At most one of the following must be present */
    str: number;
    num: number;
    /**
     * Should only be present when num is present.
     * Specifies the units of num.
     * Use arbitrary string (for example, "requests") as a custom count unit.
     * If no unit is specified, consumer may apply heuristic to deduce the unit.
     * Consumers may also  interpret units like "bytes" and "kilobytes" as memory
     * units and units like "seconds" and "nanoseconds" as time units,
     * and apply appropriate unit conversions to these.
     */
    numUnit: number;
}
export interface Mapping {
    /** Unique nonzero id for the mapping. */
    id: number;
    /** Address at which the binary (or DLL) is loaded into memory. */
    memoryStart: number;
    /** The limit of the address range occupied by this mapping. */
    memoryLimit: number;
    /** Offset in the binary that corresponds to the first mapped address. */
    fileOffset: number;
    /**
     * The object this entry is loaded from.  This can be a filename on
     * disk for the main binary and shared libraries, or virtual
     * abstractions like "[vdso]".
     */
    filename: number;
    /**
     * A string that uniquely identifies a particular program version
     * with high probability. E.g., for binaries generated by GNU tools,
     * it could be the contents of the .note.gnu.build-id field.
     */
    buildId: number;
    /** The following fields indicate the resolution of symbolic info. */
    hasFunctions: boolean;
    hasFilenames: boolean;
    hasLineNumbers: boolean;
    hasInlineFrames: boolean;
}
/** Describes function and line table debug information. */
export interface Location {
    /**
     * Unique nonzero id for the location.  A profile could use
     * instruction addresses or any integer sequence as ids.
     */
    id: number;
    /**
     * The id of the corresponding profile.Mapping for this location.
     * It can be unset if the mapping is unknown or not applicable for
     * this profile type.
     */
    mappingId: number;
    /**
     * The instruction address for this location, if available.  It
     * should be within [Mapping.memory_start...Mapping.memory_limit]
     * for the corresponding mapping. A non-leaf address may be in the
     * middle of a call instruction. It is up to display tools to find
     * the beginning of the instruction if necessary.
     */
    address: number;
    /**
     * Multiple line indicates this location has inlined functions,
     * where the last entry represents the caller into which the
     * preceding entries were inlined.
     *
     * E.g., if memcpy() is inlined into printf:
     *    line[0].function_name == "memcpy"
     *    line[1].function_name == "printf"
     */
    line: Line[];
    /**
     * Provides an indication that multiple symbols map to this location's
     * address, for example due to identical code folding by the linker. In that
     * case the line information above represents one of the multiple
     * symbols. This field must be recomputed when the symbolization state of the
     * profile changes.
     */
    isFolded: boolean;
}
export interface Line {
    /** The id of the corresponding profile.Function for this line. */
    functionId: number;
    /** Line number in source code. */
    line: number | Long;
}
export interface Function {
    /** Unique nonzero id for the function. */
    id: number;
    /** Name of the function, in human-readable form if available. */
    name: number;
    /**
     * Name of the function, as identified by the system.
     * For instance, it can be a C++ mangled name.
     */
    systemName: number;
    /** Source file containing the function. */
    filename: number;
    /** Line number in source file. */
    startLine: number;
}
export declare const Profile: {
    encode(message: Profile, writer?: Writer): Writer;
    fromPartial(object: Partial<Profile>): Profile;
};
export declare const ValueType: {
    encode(message: ValueType, writer?: Writer): Writer;
    fromPartial(object: Partial<ValueType>): ValueType;
};
export declare const Sample: {
    encode(message: Sample, writer?: Writer): Writer;
    fromPartial(object: Partial<Sample>): Sample;
};
export declare const Label: {
    encode(message: Label, writer?: Writer): Writer;
    fromPartial(object: Partial<Label>): Label;
};
export declare const Mapping: {
    encode(message: Mapping, writer?: Writer): Writer;
    fromPartial(object: Partial<Mapping>): Mapping;
};
export declare const Location: {
    encode(message: Location, writer?: Writer): Writer;
    fromPartial(object: Partial<Location>): Location;
};
export declare const Line: {
    encode(message: Line, writer?: Writer): Writer;
    fromPartial(object: Partial<Line>): Line;
};
export declare const Function: {
    encode(message: Function, writer?: Writer): Writer;
    fromPartial(object: Partial<Function>): Function;
};
